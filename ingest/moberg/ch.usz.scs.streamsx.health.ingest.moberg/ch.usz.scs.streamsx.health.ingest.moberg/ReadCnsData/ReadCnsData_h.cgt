/* Additional includes go here */
namespace CNSDataAccess
{
	class DataAccess;
	class CPayload;
	class CAspects;
}

namespace CNSDataAccessWrapper
{
	class IcuDataAccess;
	class DataSettingsFile;
	class IcuDataSource;
}

<%SPL::CodeGen::headerPrologue($model);%>

#define PLATFORM_LINUX
#include "icu/cns/mrtypes.h"  // ClockTime typedef

typedef struct {
	CNSDataAccessWrapper::IcuDataAccess* dataAccess;
	std::string patientId;
	std::string medicalRecordNumber;

} ProcessingContext;


class MY_OPERATOR : public MY_BASE_OPERATOR 
{
public:
	
  // Constructor
  MY_OPERATOR();

  // Destructor
  virtual ~MY_OPERATOR(); 

  // Notify port readiness
  void allPortsReady(); 

  // Notify pending shutdown
  void prepareToShutdown(); 

  // Processing for source and threaded operators   
  void process(uint32_t idx);

  // Tuple processing for non-mutating ports
  void process(Tuple const & tuple, uint32_t port);
    
private:
    
  void processAspectHistoricAndLive(CNSDataAccess::CAspects& aspect, CNSDataAccessWrapper::IcuDataSource* cns_source);
  
  // can not be const because payload.GetMessagesAt() is not const. 
  void processMeasurements(
		  	CNSDataAccessWrapper::DataSettingsFile& dataSettingsFile,
		  	CNSDataAccess::CPayload& payload,  
		    const ClockTime timestamp,
		    const std::string units,
			const size_t& i,
			const float& m, const float& b);
  

  void processCompositeMeasurements(
  		CNSDataAccessWrapper::DataSettingsFile& dataSettingsFile,
  		CNSDataAccess::CPayload& payload, 
		const std::string& mrn, 
		const std::string& aspect, 
		const std::string& correctedTimestamp,
  	    const std::string units,
  		const size_t& i,
  		const float& m, const float& b);
  
  
  void setEventTuple(
		  CNSDataAccess::CPayload& payload, 
		  const size_t& i,
		  OPort1Type& tuple) const;
  
  void sendMeasurementTuple(
		  const std::string& mrn, 
		  const std::string& aspect,
		  const std::string& timestamp,
		  const std::string& unit,
		  const float& value);
  
  void sendMeasurementTupleInt(
		  const std::string& mrn, 
		  const std::string& aspect,
		  const std::string& timestamp,
		  const std::string& unit,
		  const int& value);
  

  void submitEventTuples(CNSDataAccess::CPayload& payload);
  
  // can not be const because payload.GetMessagesAt() is not const. 
  void submitDataTuples(
		  CNSDataAccessWrapper::IcuDataSource* cns_source, 
		  CNSDataAccess::CPayload& payload,
		  const float64 m, const float64 b);
  
  
  float32 convertSampleSeriesValue(const float32 &value, const float64& m, const float64& b) const;
  int32 convertSampleSeriesValueInt(const int32 &value, const float64& m, const float64& b) const;
  std::string convertTimestamp(const int64 timestamp) const;  
  int getFirstCompositeElementsValueType(const std::string& firstElement) const;

  void switchPatientIfNeeded();
  void prepareNextPatient(const std::string& pid, const std::string& mrn); // TODO: delete
  
  void handlePatient(const std::string& next_pid, const std::string& next_mrn, const bool next_is_valid);
  void openPatientDirectory(const std::string& pid, const std::string& mrn);
  void createNextContext(const std::string& pid, const std::string& mrn);
  void deleteNextContext();
  
  bool getCurrentPatientIsValid();
  std::string getCurrentMrn();
  std::string getCurrentPid();
  std::vector <CNSDataAccess::CAspects> getCurrentAspects();

  float64 updateSampleConversionsSlopeParam(CNSDataAccessWrapper::IcuDataSource* cns_source, const std::string& type) const;
  float64 updateSampleConversionYInterceptParam(CNSDataAccessWrapper::IcuDataSource* cns_source, const std::string& type) const;

  std::string cns_archive_;
  int cns_sleep_ms_;
  ClockTime cns_payload_duration_usec_; 
  
  ProcessingContext* current_context_;
  ProcessingContext* next_context_;
  bool context_change_needed_;
  bool current_is_valid_;
  bool next_is_valid_;

  // Mutex protecting data in next_context_ Context and the context switch.
  // Data in current_context_ need not be protected, because only the process loop accesses it (and does the context switch)
  Mutex context_mutex_; 
  
}; 

<%SPL::CodeGen::headerEpilogue($model);%>


