<%SPL::CodeGen::implementationPrologue($model);%>

#define PLATFORM_LINUX

#include "icu/cns/IcuDataAccess.h"
#include "icu/cns/IcuDataSource.h"
#include "icu/cns/IcuCnsAccessWrapperException.h"

#include <vector>
#include <limits>
#include <time.h>
#include <exception>


MY_OPERATOR::MY_OPERATOR():
		current_context_(NULL), next_context_(NULL), context_change_needed_(false), 
		current_is_valid_(false), next_is_valid_(false)
{
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: Constructor", "");

	// get value from SPL
	<%
		my $cnsArchiveRootParam = $model->getParameterByName("cnsArchiveRoot");
		my $cnsArchiveRootValue = $cnsArchiveRootParam->getValueAt(0)->getCppExpression();

		my $cnsSleepMsParam = $model->getParameterByName("cnsSleepMs");
		my $cnsSleepMsValue = (not $cnsSleepMsParam) ? "0" : $cnsSleepMsParam->getValueAt(0)->getCppExpression();
		
		my $cnsPayloadDurationUsecParam = $model->getParameterByName("cnsPayloadDurationUsec");
		my $cnsPayloadDurationUsecValue = (not $cnsPayloadDurationUsecParam) ? "0" : $cnsPayloadDurationUsecParam->getValueAt(0)->getCppExpression();
	%>
	cns_archive_ = <%=$cnsArchiveRootValue%>;
	cns_sleep_ms_ = <%=$cnsSleepMsValue%>;
	cns_payload_duration_usec_ = <%=$cnsPayloadDurationUsecValue%>;
	   
}
 
// Destructor
MY_OPERATOR::~MY_OPERATOR() {
	// Finalization code goes here
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: Destructor", "");
	
	delete current_context_;
	delete next_context_;
}



// Notify port readiness
void MY_OPERATOR::allPortsReady() {
	// Notifies that all ports are ready. No tuples should be submitted before
	// this. Source operators can use this method to spawn threads.
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: allPortsReady", "");

	createThreads(1); // Create source thread
}

// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() {
	// This is an asynchronous call

	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: prepareToShutdown", "");
}

// Tuple processing for non-mutating ports
// This is where patientInfo input-tuples get processed
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port) {
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: process (const Tuple&, port) on port " << port, "");

	if (port == 0) {
		
		IPort0Type const & tuple_patient = static_cast<IPort0Type const &>(tuple);
		SPL::rstring pid = tuple_patient.get_patientId();
		SPL::rstring mrn = tuple_patient.get_MedicalRecordNumber();
		bool is_valid_patient = tuple_patient.get_isValid();

		handlePatient(pid, mrn, is_valid_patient);
			
	} 
}

void MY_OPERATOR::handlePatient(const std::string& next_pid, const std::string& next_mrn, const bool next_is_valid) {

	if(context_change_needed_) {
		return;
	}
	
	std::string current_mrn = getCurrentMrn();
	bool current_is_valid = getCurrentPatientIsValid();
	
	if ( !current_is_valid && next_is_valid) {

		createNextContext(next_pid, next_mrn);
		openPatientDirectory(next_pid, next_mrn);

		SPLAPPTRC(L_INFO, "New patient admitted with medical record number '" << next_mrn << "'.", "");

	} else if (current_is_valid && !next_is_valid) {
		deleteNextContext();
		
		SPLAPPTRC(L_INFO, "Patient with medical record number '" << current_mrn << "' got discharged.", "");
	} else if (current_is_valid && next_is_valid && (next_mrn.compare(current_mrn) != 0)) {

		createNextContext(next_pid, next_mrn);
		openPatientDirectory(next_pid, next_mrn); // needs to be updated because context will change

		SPLAPPTRC(L_INFO, "Currently admitted patient has a new medical record number '" << next_mrn << "'.", "");

	}
	// else do nothing
	
}

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx) {
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: process(" << idx <<")", "");

	int run = 0;

	while (!getPE().getShutdownRequested()) {
		
		try {

			struct timespec pause = {0};
			pause.tv_sec = 0;
			pause.tv_nsec = cns_sleep_ms_ * 1000000L;
			nanosleep(&pause, (struct timespec *)NULL);
	
			switchPatientIfNeeded();
			
			// quick way out if we don't have a patient directory
			if (current_context_ == NULL)
			{
				SPLAPPTRC(L_DEBUG, "No patient context.", "");
				continue;
			}		
			
			SPLAPPTRC(L_DEBUG, "Run '" << run++ << "'", "");
			
			std::vector < CNSDataAccess::CAspects > aspects = getCurrentAspects();
	
			for (size_t type_idx = 0; type_idx < aspects.size(); ++type_idx) {
				CNSDataAccess::CAspects& aspect = aspects.at(type_idx);
				
				try {
				
					CNSDataAccessWrapper::IcuDataSource* cns_source;
					{ AutoMutex am (context_mutex_); 
						cns_source = current_context_->dataAccess->getDataSource(aspect.baseTypeString()); 
					}
					
					
					if (cns_source == NULL) {
						SPLAPPTRC(L_INFO, "CNS data source not found for aspect '" << aspect.toString() << "'.", "");
						continue;
					}
		
					// replace the next line if you want to review data differently
					processAspectHistoricAndLive(aspect, cns_source);
	
				} catch(const CNSDataAccessWrapper::IcuCnsAccessWrapperException& e) {
					SPLAPPTRC(L_INFO, "IcuCnsAccessWrapperException exception during processing of aspect '" << aspect.toString() << "'. " << e.what(), "");
				} catch(const std::exception& e) {
					SPLAPPTRC(L_INFO, "Exception during processing of aspect '" << aspect.toString() << "'. " << e.what(), "");
				} catch(...) {
					SPLAPPTRC(L_INFO, "Unknown exception during processing of aspect '" << aspect.toString() << "'.", "");
				}
				
			} // end aspects
			SPLAPPTRC(L_TRACE, "Done all aspects.", "");
			
			
		} catch(const CNSDataAccessWrapper::IcuCnsAccessWrapperException& e) {
			SPLAPPTRC(L_INFO, "IcuCnsAccessWrapperException exception: " << e.what(), "");
		} catch(const std::exception& e) {
			SPLAPPTRC(L_INFO, "Exception: " << e.what(), "");
		} catch(...) {
			SPLAPPTRC(L_INFO, "Unknown exception during CNS Read process method for patient '" << getCurrentMrn() << "'.", "");
		}
	}
	
	SPLAPPTRC(L_INFO, "Operator ReadCnsData: leaving process(" << idx <<")", "");

}


void MY_OPERATOR::processAspectHistoricAndLive(CNSDataAccess::CAspects& aspect, CNSDataAccessWrapper::IcuDataSource* cns_source) {

	CNSDataAccess::CPayload payload;

	SPLAPPTRC(L_DEBUG, "Processing " 
			<< aspect.toString() 
			<< " from '" 
			<< "' ...", "");
	
	float64 m = updateSampleConversionsSlopeParam(cns_source, aspect.Type());
	float64 b = updateSampleConversionYInterceptParam(cns_source, aspect.Type());
	
	while (cns_source->read(cns_payload_duration_usec_, payload)) {
		
		SPLAPPTRC(L_DEBUG, "Payload count '" << payload.Count() << "', for type " << payload.Type(), "");
			
		if (payload.Type() == CNSDataAccess::CHAR_AGGREGATE) {
			SPLAPPTRC(L_TRACE, "Received new event...", "");
			
			submitEventTuples(payload);
		
		} else if (payload.Type() == CNSDataAccess::FLOAT_AGGREGATE 
				|| payload.Type() == CNSDataAccess::INTEGER_AGGREGATE
				|| payload.Type() == CNSDataAccess::COMPOSITE_AGGREGATE ) {

			submitDataTuples(cns_source, payload, m, b);
				
		} else {
			SPLAPPTRC(L_WARN, "Unknown value type '" << payload.Type() << "'", "");								
		}
		
		SPLAPPTRC(L_TRACE, "Done reading.", "");
									
	} // end while loop payload
	
	SPLAPPTRC(L_TRACE, "Aspect '" << aspect.toString() << "' done.", "");

}

void MY_OPERATOR::switchPatientIfNeeded() {
	{ AutoMutex am (context_mutex_); 
	
	if (context_change_needed_) {
			SPLAPPTRC(L_INFO, "Switching patient context...", "");
			
			if (current_context_ != NULL ) {
				delete current_context_;
			}
			if (next_context_ != NULL ) {
				current_context_ = next_context_;
			}
			next_context_ = NULL;
			
			current_is_valid_ = next_is_valid_;
			
			context_change_needed_ = false;
		
			SPLAPPTRC(L_INFO, "Switched patient context.", "");
		
	}
 }


float64 MY_OPERATOR::updateSampleConversionsSlopeParam(
		CNSDataAccessWrapper::IcuDataSource* cns_source, 
		const std::string& type) const {
	float64 m = 1.0;
	if (type.compare("SampleSeries") == 0)
	{
		m =(float64)(cns_source->getSettingsFile().getM());	
		
		SPLAPPTRC(L_TRACE, "SampleSeries, conversion slope param m = '" << m << "'.", "");
	}
	return m;
}

float64 MY_OPERATOR::updateSampleConversionYInterceptParam(
		CNSDataAccessWrapper::IcuDataSource* cns_source, 
		const std::string& type) const {
	float64 b = 0.0;
	if (type.compare("SampleSeries") == 0)
	{
		b =(float64)(cns_source->getSettingsFile().getB());	
		
		SPLAPPTRC(L_TRACE, "SampleSeries, conversion b-intercept param b = '" << b << "'.", "");
	}
	return b;
}

void MY_OPERATOR::submitDataTuples(
		CNSDataAccessWrapper::IcuDataSource* cns_source, 
		CNSDataAccess::CPayload& payload,
		const float64 m, const float64 b) {
	
	std::vector<ClockTime> sampleTimes;
	cns_source->getSampleTimestamps(payload, sampleTimes);
	std::string units = *cns_source->getSettingsFile().getUnits();
	SPLAPPTRC(L_DEBUG, "Unit = '" << units << "'.", "");

	for (size_t i = 0; i < payload.Count(); i++) {
		processMeasurements(cns_source->getSettingsFile(), payload, sampleTimes[i], units, i, m, b);
	}
	
}

void MY_OPERATOR::submitEventTuples(CNSDataAccess::CPayload& payload) {
	
	for (size_t i = 0; i < payload.Count(); i++) {
		OPort1Type tuple;
		setEventTuple(payload, i, tuple);
		submit(tuple, 1); 	
	}
}

void MY_OPERATOR::setEventTuple(
		CNSDataAccess::CPayload& payload,
	    const size_t& i,
		OPort1Type& tuple) const {

	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple", "");
	
	tuple.set_MedicalRecordNumber(current_context_->medicalRecordNumber);
	
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple setMedicalRecordNumber", "");
	
	tuple.set_Aspect(payload.Aspects().baseTypeString());
	
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple setAspect", "");
	
	std::string iso8601time = convertTimestamp(payload.ValueList()[i].m_time);
	
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple convertTimestamp", "");
	
	tuple.set_Timestamp(iso8601time);
	
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: START setEventTuple setTimestamp", "");
	
	// TODO:  SAMANTHA - this line of code causes the operator to crash
        // HINT: SUS: that might be a null pointer exception? if payload.ValueList() is not initialized and we call it on i
        // HINT: SUS: check either payload.Count() or similar
	tuple.set_Message(payload.ValueList()[i].value.sValue);
	
	SPLAPPTRC(L_TRACE, "Operator ReadCnsData: END setEventTuple", "");
}

void MY_OPERATOR::processCompositeMeasurements(
		CNSDataAccessWrapper::DataSettingsFile& dataSettingsFile,
		CNSDataAccess::CPayload& payload, 
		const std::string& mrn, 
		const std::string& aspect, 
	    const std::string& correctedTimestamp,
	    const std::string units,
		const size_t& i,
		const float& m, const float& b) {
		
	std::vector<std::string> compositeElements = *dataSettingsFile.getCompositeElements();
	int numComposites = std::min<int>(payload.NumCompositeElements(), compositeElements.size());
	SPLAPPTRC(L_DEBUG, "Number of composite elements '" << numComposites << "'", "");

	if (numComposites <= 0) {
		return;
	}

	// assume all composite elements have same value type. 
	int valueType = getFirstCompositeElementsValueType(compositeElements.at(0));

	if (valueType == 0) {
		return;
	}
			
	// FIXME: do template function
	if (valueType == 1) {
		float32* data = (float32*)payload.IntCompositeSet(i);
		float32 value2;
		for (int j = 0; j < numComposites; j++) {
			float32& value = data[j];

			float32 value2 = convertSampleSeriesValue(value, m, b);
			SPLAPPTRC(L_TRACE, "Sending composite tuple '" << j << "' with value '" << value2 << "'", "");
			sendMeasurementTuple(current_context_->medicalRecordNumber, 
								(compositeElements)[j],		
								correctedTimestamp,		
								units,
								convertSampleSeriesValue(value, m, b));
		}
	}
	else if (valueType == 2) {

		int32* data = (int32*)payload.IntCompositeSet(i);
		int32 value2;
		for (int j = 0; j < numComposites; j++) {
			int32& value = data[j];

			value2 = convertSampleSeriesValueInt(value, m, b);
			SPLAPPTRC(L_TRACE, "Sending composite tuple '" << j << "' with value '" << value2 << "'", "");
			sendMeasurementTupleInt(current_context_->medicalRecordNumber, 
								(compositeElements)[j],		
								correctedTimestamp,		
								units,
								convertSampleSeriesValueInt(value, m, b));
			
		}
	}
}

void MY_OPERATOR::processMeasurements(
		CNSDataAccessWrapper::DataSettingsFile& dataSettingsFile,
		CNSDataAccess::CPayload& payload, 
	    const ClockTime timestamp,
	    const std::string units,
		const size_t& i,
		const float& m, const float& b) {
	
	//SPLAPPTRC(L_TRACE, "Operator ReadCnsData: setMeasurementTuple, i=" << i, "");

	std::string correctedTimestamp = convertTimestamp(timestamp);

	if (payload.Type() == CNSDataAccess::FLOAT_AGGREGATE) {
		float32 value = payload.FloatData()[i];
		value = convertSampleSeriesValue(value, m, b);
		sendMeasurementTuple(current_context_->medicalRecordNumber, 
							payload.Aspects().baseTypeString(),
							correctedTimestamp,
							units,
							value);
		
	} else if (payload.Type() == CNSDataAccess::INTEGER_AGGREGATE) {
		int value = payload.IntData()[i];

		sendMeasurementTuple(current_context_->medicalRecordNumber, 
							payload.Aspects().baseTypeString(),
							correctedTimestamp,
							units,
							convertSampleSeriesValueInt(value, m, b));
	} else if (payload.Type() == CNSDataAccess::COMPOSITE_AGGREGATE) {
		processCompositeMeasurements(
				dataSettingsFile, 
				payload,
				current_context_->medicalRecordNumber, 
				payload.Aspects().baseTypeString(),
				correctedTimestamp, 
				units,
				i,
				m,
				b);		
	}
}

void MY_OPERATOR::sendMeasurementTupleInt(
		  const std::string& mrn, 
		  const std::string& aspect,
		  const std::string& timestamp,
		  const std::string& unit,
		  const int& value)  {
	
	OPort0Type tuple;

	tuple.set_MedicalRecordNumber(mrn);
	tuple.set_Aspect(aspect);
	tuple.set_Timestamp(timestamp);
	SPL::rstring unitutf = SPL::Functions::String::convertToUtf8(unit, "ISO-8859-1");	
	tuple.set_Unit(unitutf);
	
	tuple.get_Data().push_back(value);
	
	submit(tuple, 0); 
}

void MY_OPERATOR::sendMeasurementTuple(
		  const std::string& mrn, 
		  const std::string& aspect,
		  const std::string& timestamp,
		  const std::string& unit,
		  const float& value)  {
	
	OPort0Type tuple;

	tuple.set_MedicalRecordNumber(mrn);
	tuple.set_Aspect(aspect);
	tuple.set_Timestamp(timestamp);
	SPL::rstring unitutf = SPL::Functions::String::convertToUtf8(unit, "ISO-8859-1");	
	tuple.set_Unit(unitutf);
	
	tuple.get_Data().push_back(value);
	
	submit(tuple, 0); 
}


float32 MY_OPERATOR::convertSampleSeriesValue(const float32 &value, const float64& m, const float64& b) const {
	float32 converted_value = (float32)(((float64)value) * m + b);
	return converted_value;
}

int32 MY_OPERATOR::convertSampleSeriesValueInt(const int32 &value, const float64& m, const float64& b) const {
	float32 tmp = (float64)value;
	float32 converted_value = (float32)((tmp)* m + b);
	return (int32)converted_value;
}

int MY_OPERATOR::getFirstCompositeElementsValueType(const std::string& firstElement) const {

	std::size_t foundFloat = firstElement.find("Float");
	std::size_t foundInt = firstElement.find("Integer");
	int valueType = 0; // FIXME: make enum, default undefined
	if (foundFloat != std::string::npos) {
		valueType = 1;
	}
	else if (foundInt != std::string::npos) {
		valueType = 2;
	}
	return valueType;
}


void MY_OPERATOR::deleteNextContext() {
	{ AutoMutex am (context_mutex_); 
		delete next_context_;
		next_context_ = NULL;
		next_is_valid_ = false;
		context_change_needed_ = true;
	}
}

void MY_OPERATOR::createNextContext(const std::string& pid, const std::string& mrn) {
	{ AutoMutex am (context_mutex_); 
	
		next_context_ = new ProcessingContext;
		next_context_->patientId = pid;
		next_context_->medicalRecordNumber = mrn;
		next_context_->dataAccess = new CNSDataAccessWrapper::IcuDataAccess();
		next_context_->dataAccess->SetRootPath(cns_archive_); 
		
		next_is_valid_ = true;
		
		context_change_needed_ = true;
		
	}
}

void MY_OPERATOR::openPatientDirectory(const std::string& pid, const std::string& mrn) {
	SPLAPPTRC(L_TRACE, "Attempting to open patient '" << pid << "', with medical record number '" << mrn << "'...", "");

	{ AutoMutex am (context_mutex_); 
		
		if (next_context_->dataAccess->OpenPatient(pid)) {
			SPLAPPTRC(L_TRACE, "Patient folder successfully opened '" << pid << "'.", "");
		} else {
			// could not open new patient's folder - stay with current patient.
			delete next_context_;
			next_context_ = NULL;
			next_is_valid_ = false;
			
			SPLAPPTRC(L_WARN, "Could not open patient folder with pid '" << pid << "'.", "");	
		}
			
	}
}

bool MY_OPERATOR::getCurrentPatientIsValid() {
	bool is_valid = false;
	{ AutoMutex am (context_mutex_); 
	    is_valid = current_is_valid_;
	}
	return is_valid;
}

std::string MY_OPERATOR::getCurrentPid() {
	std::string pid = "";
	{ AutoMutex am (context_mutex_); 
	    if (current_context_ != NULL) {
	    	pid = current_context_->patientId;
	    }
	}
	return pid;
}

std::string MY_OPERATOR::getCurrentMrn() {
	std::string mrn = "";
	{ AutoMutex am (context_mutex_); 
		if (current_context_ != NULL) {
			mrn = current_context_->medicalRecordNumber;
		}
	}
	return mrn;
}

std::vector < CNSDataAccess::CAspects > MY_OPERATOR::getCurrentAspects() {
	std::vector < CNSDataAccess::CAspects > aspects;
	{ AutoMutex am (context_mutex_); 
		aspects = current_context_->dataAccess->GetStoredTypes();
	}
	SPLAPPTRC(L_TRACE, "Number of stored aspects found: '" << aspects.size() << "'", "");
	
	return aspects;
}


std::string MY_OPERATOR::convertTimestamp(const int64 timestamp) const {
	time_t seconds = timestamp / 1000000;
	int us = timestamp % 1000000;

	struct tm* ptm;
	ptm = gmtime (&seconds); 

	char buf[30];
	snprintf(buf, 29, "%i-%02i-%02iT%02i:%02i:%02i.%06iZ", ptm->tm_year+1900, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec, us);

	std::string result(buf);

	return buf;
}


<%SPL::CodeGen::implementationEpilogue($model);%>
