/* Generated by Streams Studio: June 22, 2016 at 5:56:15 PM EDT */
package com.ibm.streamsx.health.analyze.ecg;

import org.apache.log4j.Logger;

import com.ibm.streams.operator.AbstractOperator;
import com.ibm.streams.operator.OperatorContext;
import com.ibm.streams.operator.OutputTuple;
import com.ibm.streams.operator.StreamingData.Punctuation;
import com.ibm.streams.operator.StreamingInput;
import com.ibm.streams.operator.StreamingOutput;
import com.ibm.streams.operator.Tuple;
import com.ibm.streams.operator.TupleAttribute;
import com.ibm.streams.operator.OperatorContext.ContextCheck;
import com.ibm.streams.operator.compile.OperatorContextChecker;
import com.ibm.streams.operator.model.InputPortSet;
import com.ibm.streams.operator.model.InputPortSet.WindowMode;
import com.ibm.streams.operator.model.InputPortSet.WindowPunctuationInputMode;
import com.ibm.streams.operator.model.InputPorts;
import com.ibm.streams.operator.model.Libraries;
import com.ibm.streams.operator.model.OutputPortSet;
import com.ibm.streams.operator.model.OutputPortSet.WindowPunctuationOutputMode;
import com.ibm.streams.operator.model.OutputPorts;
import com.ibm.streams.operator.model.Parameter;
import com.ibm.streams.operator.model.PrimitiveOperator;

import eplimited.osea.OSEAFactory;
import eplimited.osea.classification.BeatDetectionAndClassification;
import eplimited.osea.classification.BeatDetectionAndClassification.BeatDetectAndClassifyResult;

/**
 * Class for an operator that receives a tuple and then optionally submits a
 * tuple. This pattern supports one or more input streams and one or more output
 * streams.
 * <P>
 * The following event methods from the Operator interface can be called:
 * </p>
 * <ul>
 * <li><code>initialize()</code> to perform operator initialization</li>
 * <li>allPortsReady() notification indicates the operator's ports are ready to
 * process and submit tuples</li>
 * <li>process() handles a tuple arriving on an input port
 * <li>processPuncuation() handles a punctuation mark arriving on an input port
 * <li>shutdown() to shutdown the operator. A shutdown request may occur at any
 * time, such as a request to stop a PE or cancel a job. Thus the shutdown() may
 * occur while the operator is processing tuples, punctuation marks, or even
 * during port ready notification.</li>
 * </ul>
 * <p>
 * With the exception of operator initialization, all the other events may occur
 * concurrently with each other, which lead to these methods being called
 * concurrently by different threads.
 * </p>
 */
@PrimitiveOperator(name = "QRSDetector", namespace = "com.ibm.streamsx.health.analyze.ecg", description = "Java Operator QSRDetector")
@InputPorts({
		@InputPortSet(description = "Port that ingests tuples", cardinality = 1, optional = false, windowingMode = WindowMode.NonWindowed, windowPunctuationInputMode = WindowPunctuationInputMode.Oblivious) })
@OutputPorts({
		@OutputPortSet(description = "Port that produces tuples", cardinality = 1, optional = false, windowPunctuationOutputMode = WindowPunctuationOutputMode.Generating) })
@Libraries({"opt/downloaded/OSEA4J.jar", "impl/lib/*"})
public class QRSDetector extends AbstractOperator {

	private static final String DEFAULT_QRSTIMESTAMP_ATTR_NAME = "qrsTimestamp";
	private static final String DEFAULT_QRSDELAY_ATTR_NAME = "qrsDelay";
	private static final String DEFAULT_QRSCLASSIFICATION_ATTR_NAME = "qrsClassification";
	private static final String DEFAULT_RRINTERVAL_ATTR_NAME = "rrInterval";
	private static final String DEFAULT_PREVRRINTERVAL_ATTR_NAME = "rrMinusOneInterval";
	
	private static final Integer DEFAULT_SLIDING_BUFFER_SIZE = 0; // defaults to 2 x sampling rate value
	private static final boolean DEFAULT_OUTPUT_DETECTION_ONLY = true;
	
	private Logger logger = Logger.getLogger(this.getClass());
	private BeatDetectionAndClassification detector;
	private SlidingBuffer<Double> timeBuffer;	
	private Double previousQrsTimestamp;
	private Double previousRRInterval;
	
	/* Parameters */
	private TupleAttribute<Tuple, Integer> inputDataAttr ;
	private TupleAttribute<Tuple, Long> inputTimestampAttr ;
	
	private String qrsTimestampAttrName = DEFAULT_QRSTIMESTAMP_ATTR_NAME;
	private String qrsClassificationAttrName = DEFAULT_QRSCLASSIFICATION_ATTR_NAME;
	private String qrsDelayAttrName = DEFAULT_QRSDELAY_ATTR_NAME;
	private String rrIntervalAttrName = DEFAULT_RRINTERVAL_ATTR_NAME;
	private String prevRRIntervalAttrName = DEFAULT_PREVRRINTERVAL_ATTR_NAME;
	
	private int slidingBufferLength = DEFAULT_SLIDING_BUFFER_SIZE;
	private boolean outputDetectionOnly = DEFAULT_OUTPUT_DETECTION_ONLY;
	private int sampleRate;
			
	@Parameter(optional=false)
	public void setSampleRate(int sampleRate) {
		this.sampleRate = sampleRate;
	}

	@Parameter(optional=false)
	public void setInputDataAttr(TupleAttribute<Tuple, Integer> dataAttr) {
		this.inputDataAttr = dataAttr;
	}

	@Parameter(optional=false)
	public void setInputTimestampAttr(TupleAttribute<Tuple, Long> timestampAttr) {
		this.inputTimestampAttr = timestampAttr;
	}	
	
	@Parameter(optional=true, name="QRSClassificationAttrName")
	public void setQrsClassificationAttrName(String qrsClassificationAttrName) {
		this.qrsClassificationAttrName = qrsClassificationAttrName;
	}
	
	@Parameter(optional=true, name="QRSTimestampAttrName")
	public void setQrsTimestampAttrName(String delayAttrName) {
		this.qrsTimestampAttrName = delayAttrName;
	}

	@Parameter(optional=true, name="rrIntervalAttrName")
	public void setRRIntervalAttrName(String rrIntervalAttrName) {
		this.rrIntervalAttrName = rrIntervalAttrName;
	}	
	
	@Parameter(optional=true, name="rrMinusOneIntervalAttrName")
	public void setPrevRRIntervalAttrName(String prevRRIntervalAttrName) {
		this.prevRRIntervalAttrName = prevRRIntervalAttrName;
	}
	
	@Parameter(optional=true)
	public void setOutputDetectionOnly(boolean outputDetectionOnly) {
		this.outputDetectionOnly = outputDetectionOnly;
	}
	
	@Parameter(optional=true, name="numHistoricalTimestamps")
	public void setSlidingBufferLength(int slidingBufferLength) {
		this.slidingBufferLength = slidingBufferLength;
	}

	public int getSampleRate() {
		return sampleRate;
	}

	public TupleAttribute<Tuple, Integer> getInputDataAttr() {
		return inputDataAttr;
	}
	
	public TupleAttribute<Tuple, Long> getInputTimestampAttr() {
		return inputTimestampAttr;
	}
	
	public String getQrsClassificationAttrName() {
		return qrsClassificationAttrName;
	}

	public String getQrsTimestampAttrName() {
		return qrsTimestampAttrName;
	}

	public String getQrsDelayAttrName() {
		return qrsDelayAttrName;
	}

	public String getRRIntervalAttrName() {
		return rrIntervalAttrName;
	}
	
	public String getPrevRRIntervalAttrName() {
		return this.prevRRIntervalAttrName;
	}
	
	public int getSlidingBufferLength() {
		if(this.slidingBufferLength <= DEFAULT_SLIDING_BUFFER_SIZE)
			return getSampleRate() * 2;
	
		return this.slidingBufferLength;
	}
	
	public boolean isOutputDetectionOnly() {
		return outputDetectionOnly;
	}

	/**
	 * Initialize this operator. Called once before any tuples are processed.
	 * 
	 * @param context
	 *            OperatorContext for this operator.
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public synchronized void initialize(OperatorContext context) throws Exception {
		// Must call super.initialize(context) to correctly setup an operator.
		super.initialize(context);
		logger.trace("Operator " + context.getName() + " initializing in PE: "
				+ context.getPE().getPEId() + " in Job: " + context.getPE().getJobId());

		timeBuffer = new SlidingBuffer<>(getSlidingBufferLength());
		previousQrsTimestamp = Double.NaN;
		previousRRInterval = Double.NaN;
		initDetector();
	}

	private void initDetector() {
		int sampleRate = getSampleRate();
		detector = OSEAFactory.createBDAC(sampleRate, sampleRate/2);
	}
	
	@ContextCheck(runtime=true)
	public static void checkOutputSchema(OperatorContextChecker checker) throws Exception {
		// TODO
	}
	
	/**
	 * Notification that initialization is complete and all input and output
	 * ports are connected and ready to receive and submit tuples.
	 * 
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public synchronized void allPortsReady() throws Exception {
		OperatorContext context = getOperatorContext();
		logger.trace("Operator " + context.getName() + " all ports are ready in PE: "
				+ context.getPE().getPEId() + " in Job: " + context.getPE().getJobId());
	}

	/**
	 * Process an incoming tuple that arrived on the specified port.
	 * <P>
	 * Copy the incoming tuple to a new output tuple and submit to the output
	 * port.
	 * </P>
	 * 
	 * @param inputStream
	 *            Port the tuple is arriving on.
	 * @param tuple
	 *            Object representing the incoming tuple.
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public final void process(StreamingInput<Tuple> inputStream, Tuple tuple) throws Exception {
		int sample = getInputDataAttr().getValue(tuple);
		double timestamp = getInputTimestampAttr().getValue(tuple);
		timeBuffer.add(timestamp);
		
		BeatDetectAndClassifyResult result = detector.BeatDetectAndClassify(sample);
		logger.trace("tuple=" + tuple.toString());
		logger.trace("result=" + result);
		
		if (!isOutputDetectionOnly() || (isOutputDetectionOnly() && result.samplesSinceRWaveIfSuccess != 0)) {
			StreamingOutput<OutputTuple> outStream = getOutput(0);
			OutputTuple outTuple = outStream.newTuple();
			outTuple.assign(tuple);

			Double qrsTimestamp = Double.NaN;
			int qrsPosition = -1;
			Double rrInterval = Double.NaN;
			Double rrMinusOneInterval = Double.NaN;
			if(result.samplesSinceRWaveIfSuccess != 0) {
				// calculate timestamp for detected QRS
				qrsPosition = result.samplesSinceRWaveIfSuccess;
				if(qrsPosition <= timeBuffer.size()) {
					qrsTimestamp = calculateTimestampFromQrsPosition(qrsPosition);
				} else {
					logger.error("Detected position larger than available historical data points: qrsPosition=" + qrsPosition);
				}
				
				// calculate RR interval
				if(qrsTimestamp != Double.NaN) {
					if(previousQrsTimestamp != Double.NaN) {
						rrMinusOneInterval = previousRRInterval;
						rrInterval = calculateRRInterval(qrsTimestamp);
						previousRRInterval = rrInterval;
					}
					previousQrsTimestamp = qrsTimestamp;
				}
			}
			
			outTuple.setLong(getQrsTimestampAttrName(), Math.round(qrsTimestamp));
			outTuple.setInt(getQrsDelayAttrName(), qrsPosition);
			outTuple.setString(getQrsClassificationAttrName(), BeatType.getByCode(result.beatType).toString());
			outTuple.setDouble(getRRIntervalAttrName(), rrInterval);
			outTuple.setDouble(getPrevRRIntervalAttrName(), rrMinusOneInterval);
			
			outStream.submit(outTuple);
		}
	}
	
	private Double calculateRRInterval(Double qrsTimestamp) {
		return qrsTimestamp - previousQrsTimestamp;
	}
	
	private Double calculateTimestampFromQrsPosition(int qrsPosition) {
		return timeBuffer.get(timeBuffer.size() - 1 - qrsPosition);
	}
	
	/**
	 * Process an incoming punctuation that arrived on the specified port.
	 * 
	 * @param stream
	 *            Port the punctuation is arriving on.
	 * @param mark
	 *            The punctuation mark
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	@Override
	public void processPunctuation(StreamingInput<Tuple> stream, Punctuation mark) throws Exception {
		// For window markers, punctuate all output ports
		super.processPunctuation(stream, mark);
		
		if(mark == Punctuation.WINDOW_MARKER) {
			// window marker indicates the start of a new record
			// initialize a new detector
			initDetector();
		}
	}

	/**
	 * Shutdown this operator.
	 * 
	 * @throws Exception
	 *             Operator failure, will cause the enclosing PE to terminate.
	 */
	public synchronized void shutdown() throws Exception {
		OperatorContext context = getOperatorContext();
		logger.trace("Operator " + context.getName() + " shutting down in PE: "
				+ context.getPE().getPEId() + " in Job: " + context.getPE().getJobId());

		super.shutdown();
	}
}
